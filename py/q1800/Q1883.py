"""
 * 给你一个整数 hoursBefore ，表示你要前往会议所剩下的可用小时数。要想成功抵达会议现场，你必须途经 n 条道路。道路的长度用一个长度为 n 的整数数组 dist 表示，其中 dist[i] 表示第 i 条道路的长度（单位：千米）。另给你一个整数 speed ，表示你在道路上前进的速度（单位：千米每小时）。
 * 当你通过第 i 条路之后，就必须休息并等待，直到 下一个整数小时 才能开始继续通过下一条道路。注意：你不需要在通过最后一条道路后休息，因为那时你已经抵达会议现场。
 * 例如，如果你通过一条道路用去 1.4 小时，那你必须停下来等待，到 2 小时才可以继续通过下一条道路。如果通过一条道路恰好用去 2 小时，就无需等待，可以直接继续。
 * 然而，为了能准时到达，你可以选择 跳过 一些路的休息时间，这意味着你不必等待下一个整数小时。注意，这意味着与不跳过任何休息时间相比，你可能在不同时刻到达接下来的道路。
 * 例如，假设通过第 1 条道路用去 1.4 小时，且通过第 2 条道路用去 0.6 小时。跳过第 1 条道路的休息时间意味着你将会在恰好 2 小时完成通过第 2 条道路，且你能够立即开始通过第 3 条道路。
 * 返回准时抵达会议现场所需要的 最小跳过次数 ，如果 无法准时参会 ，返回 -1 。
 * 提示：
 * 1、n == dist.length
 * 2、1 <= n <= 1000
 * 3、1 <= dist[i] <= 10^5
 * 4、1 <= speed <= 10^6
 * 5、1 <= hoursBefore <= 10^7
 * 链接：https://leetcode.cn/problems/minimum-skips-to-arrive-at-meeting-on-time/
"""
from math import ceil
from typing import List
"""
 * 浮点数运算的细节
 * 根据 IEEE 754 标准，浮点数在计算机中存储的精度是有限的，而本题中我们不可避免的会使用「浮点数运算」以及「向上取整」运算，如果强行忽略产生的计算误差，会得到错误的结果。
 * 举一个简单的例子，假设使用的语言中「向上取整」运算的函数为  ceil，下面的运算：
 * ceil(8.0 + 1.0 / 3 + 1.0 / 3 + 1.0 / 3)
 * 应当是 9，而计算机会给出 10。这是因为浮点数误差导致：
 * 8.0 + 1.0 / 3 + 1.0 / 3 + 1.0 / 3
 * 计算出的结果约为：
 * 9.000000000000002
 * 向上取整后会得到 10，产生了错误的答案。
 * 因此我们引入常量 eps 表示一个极小值，例如 10^-8 。在进行「向上取整」运算前，我们将待取整的浮点数减去 eps 再进行取整，就可以避免上述的误差。
 * 同时，我们需要说明 eps 不会引入其它的问题。在本题中速度最大为 10^6 ，时间与速度成反比，那么 eps 的粒度只需要高于时间的精度 10^-6 即可，取 10^-7 或 10^-8 都是可行的。
 * 最后在比较 f[n][j] ≤ hoursBefore 时，我们也需要将左侧减去 eps 或将右侧加上 eps，再进行比较。
"""


class Solution:

    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:
        n = len(dist)
        EPS = 1e-7  # 可忽略误差 这玩意要卡精度
        # dp[i][j] 表示前 i 条路，跳过 j 次的最小耗时，分组讨论最后一组是否跳过，2 种情况取最小值
        # 1、跳过：dp[i][j] = dp[i - 1][j - 1] + dist[i] / speed
        # 2、不跳过：dp[i][j] = ceil(dp[i - 1][j]) + dist[i] / speed
        dp = [[2**32] * (n + 1) for _ in range(n + 1)]
        dp[0][0] = 0
        for i in range(1, n + 1):
            dp[i][0] = ceil(dp[i - 1][0]) + dist[i - 1] / speed - EPS
            for j in range(1, n + 1):
                v1 = dp[i - 1][j - 1] + dist[i - 1] / speed  # 跳过
                v2 = ceil(dp[i - 1][j]) + dist[i - 1] / speed - EPS  # 不跳过 向上取整
                dp[i][j] = min(v1, v2)
        for i in range(n + 1):
            if dp[n][i] < hoursBefore + EPS:
                return i
        return -1


if __name__ == '__main__':
    # 18
    print(Solution().minSkips([
        29, 52, 89, 32, 40, 85, 75, 48, 61, 71, 68, 45, 55, 96, 71, 43, 46, 90, 59, 35, 40, 33, 30, 16, 93, 25, 41, 16, 96, 69, 98, 89, 24, 25, 28, 95, 62, 36, 93, 76, 98, 68, 77, 37, 13, 25, 38, 30,
        47, 23, 39, 2, 91, 69, 17, 36, 6, 7, 71, 38, 90, 17, 82, 97, 63, 14, 2, 74
    ], 39, 105))
    # 0
    print(Solution().minSkips([7, 6, 5, 3, 4, 6, 2, 2, 7, 2], 5, 17))
    # 2
    print(Solution().minSkips([7, 3, 5, 5], 2, 10))
    # 1
    print(Solution().minSkips([1, 3, 2], 4, 2))
    # -1
    print(Solution().minSkips([7, 3, 5, 5], 1, 10))
