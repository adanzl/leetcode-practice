{
  // Place your py workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and
  // description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope
  // is left empty or omitted, the snippet gets applied to all languages. The prefix is what is
  // used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
  // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders.
  // Placeholders with the same ids are connected.
  // Example:
  // "Print to console": {
  // 	"scope": "javascript,typescript",
  // 	"prefix": "log",
  // 	"body": [
  // 		"console.log('$1');",
  // 		"$2"
  // 	],
  // 	"description": "Log output to console"
  // }
  "Leetcode": {
    "scope": "python,py",
    "body": [
      "\"\"\"",
      "",
      "\"\"\"",
      "from typing import *",
      "from math import *",
      "from collections import *",
      "",
      "",
      "class Solution:",
      "    def func():",
      "        ans = 0",
      "        return ans",
      "",
      "",
      "if __name__ == '__main__':",
      "    # ",
      "    print(Solution().func())"
    ],
    "prefix": "lc_template",
    "description": "Python leetcode template"
  },
  "Import typing": {
    "scope": "python,py",
    "body": [
      "\"\"\"",
      " * 链接：",
      "\"\"\"",
      "from typing import List",
      "",
      "",
      "",
      "",
      "if __name__ == '__main__':",
      "    # ",
      "    print(Solution().func())"
    ],
    "prefix": "im_type",
    "description": "Python import"
  },
  "Import LCUTIL": {
    "scope": "python,py",
    "body": [
      "import sys, os",
      "sys.path.append(os.path.dirname(__file__) + '/../')",
      "from LCUtil import *"
    ],
    "prefix": "im_util",
    "description": "Python import"
  },
  "并查集": {
    "scope": "python,py",
    "body": [
      "parent = [i for i in range(n)]",
      "def find(x):",
      "    r = x",
      "    while parent[r] != r:",
      "        r = parent[r]",
      "    while parent[x] != r:",
      "        parent[x], x = r, parent[x]",
      "    return r"
    ],
    "prefix": "union_find",
    "description": "并查集"
  },
  "线性筛质数": {
    "scope": "python,py",
    "body": [
      "LIMIT = 10**5 + 5",
      "prime_list = []",
      "b_composite = [False] * LIMIT",
      "b_composite[1] = True  # 这里 1 被算为合数",
      "",
      "def build_prime_list():",
      "    # 线性筛选质数",
      "    for i in range(2, LIMIT):",
      "        if not b_composite[i]:",
      "            prime_list.append(i)",
      "        for prime in prime_list:",
      "            nx = prime * i",
      "            if nx < LIMIT:",
      "                b_composite[nx] = True",
      "            else:",
      "                break",
      "build_prime_list()"
    ],
    "prefix": "prime_list"
  },
  "二维树状数组": {
    "scope": "python,py",
    "body": [
      "# 树状数组 下标从 1 开始，二维求和",
      "class BIT:",
      "",
      "    def __init__(self, n):",
      "        self.tree = [[0, 0]] * (n + 1)",
      "",
      "    def add(self, i, val):",
      "        while i < len(self.tree):",
      "            self.tree[i] = [self.tree[i][0] + val[0], self.tree[i][1] + val[1]]",
      "            i += i & -i  # low_bit",
      "",
      "    def query(self, i):",
      "        res = [0, 0]",
      "        while i > 0:",
      "            res = [res[0] + self.tree[i][0], res[1] + self.tree[i][1]]",
      "            i &= i - 1",
      "        return res",
      "t = BIT($1)"
    ],
    "prefix": "cls_bit_2"
  },
  "树状数组": {
    "scope": "python,py",
    "body": [
      "# 树状数组 下标从 1 开始，求和",
      "class BIT:",
      "",
      "    def __init__(self, n):",
      "        self.tree = [0] * (n + 1)",
      "",
      "    def add(self, i, val):",
      "        while i < len(self.tree):",
      "            self.tree[i] += val",
      "            i += i & -i  # low_bit",
      "",
      "    def query(self, i):",
      "        res = 0",
      "        while i > 0:",
      "            res += self.tree[i]",
      "            i &= i - 1",
      "        return res",
      "t = BIT($1)"
    ],
    "prefix": "cls_bit"
  },
  "kmp_next": {
    "scope": "python,py",
    "body": [
      "# kmp 构建next数组",
      "def build_next(ss):",
      "    next_arr = [0] * len(ss)",
      "    c = 0",
      "    for i in range(1, len(ss)):",
      "        v = ss[i]",
      "        while c and ss[c] != v:",
      "            c = next_arr[c - 1]",
      "        if ss[c] == v:",
      "            c += 1",
      "        next_arr[i] = c",
      "    return next_arr",
      ""
    ],
    "prefix": "kmp_next"
  },
  "kmp_search": {
    "scope": "python,py",
    "body": [
      "def kmp_search(s: str, pattern: str) -> int:",
      "    next_arr = build_next(pattern)",
      "    c, ans = 0, 0",
      "    for v in s:",
      "        while c and pattern[c] != v:",
      "            c = next_arr[c - 1]",
      "        if pattern[c] == v:",
      "            c += 1",
      "        if c == len(pattern):",
      "            ans += 1",
      "            c = next_arr[c - 1]",
      "    return ans"
    ],
    "prefix": "kmp_search"
  },
  "dijkstra": {
    "scope": "python,py",
    "body": [
      "INF = int(1e18)",
      "def dijkstra(src: int, next_v: List[List[List[int]]]):",
      "   dist, vis = [INF] * n, [False] * n",
      "   dist[src] = 0",
      "   q = [[0, src]]  # cost-v_idx",
      "   while q:",
      "       mn, idx = heappop(q)",
      "       if vis[idx]: continue",
      "       for nx_i, nx_c in next_v[idx]:",
      "           if nx_c + mn < dist[nx_i]:",
      "               dist[nx_i] = nx_c + mn",
      "               heappush(q, [dist[nx_i], nx_i])",
      "       vis[idx] = True",
      "   return dist"
    ],
    "prefix": "dijkstra"
  },
  "二分查找": {
    "scope": "python,py",
    "body": [
      "def check(v):",
      "    return False",
      "lo, hi = 0, 0",
      "while lo < hi:",
      "    mid = (lo + hi) // 2",
      "    if check(mid):",
      "        hi = mid",
      "    else:",
      "        lo = mid + 1"
    ],
    "prefix": "bin_search"
  },
  "字典树_AC自动机": {
    "scope": "python,py",
    "body": [
      "class Trie:",
      "",
      "    def __init__(self):",
      "        self.children = {}",
      "        self.c_end = 0  # 为单词结尾个数",
      "        self.string = ''  # 单词",
      "        self.fail = None  # 失配位置",
      "        self.last = None  # 后缀链接（suffix link），用来快速跳到一定是某个 words[k] 的最后一个字母的节点（等于 root 则表示没有）",
      "",
      "    def insert(self, s: str):",
      "        node = self",
      "        for c in s:",
      "            if c not in node.children:",
      "                node.children[c] = Trie()",
      "                node.children[c].last = self",
      "            node = node.children[c]",
      "        node.c_end += 1",
      "        node.string = s",
      "",
      "    def query(self, s) -> bool:",
      "        node = self",
      "        for c in s:",
      "            if c not in node.children:",
      "                return False",
      "            node = node.children[c]",
      "        return node.c_end != 0",
      "",
      "    def build_failed(self):",
      "        root = self",
      "        queue = [root]  # root所在层为第0层",
      "        while queue:  # 广度优先遍历",
      "            node = queue.pop(0)",
      "            # 将其孩子逐个加入列队",
      "            for i, child in node.children.items():",
      "                if node == root:",
      "                    child.fail = root  # 第1层的节点的fail总是指向root",
      "                else:",
      "                    p = node.fail  # 第2层以下的节点, 其fail是在另一个分支上",
      "                    while p:",
      "                        # 遍历它的孩子，看它们有没与当前孩子相同字符的节点",
      "                        if i in p.children:",
      "                            child.fail = p.children[i]",
      "                            # 沿着 last 往上走，可以直接跳到一定是某个 words[k] 的最后一个字母的节点（如果跳到 root 表示没有匹配）",
      "                            child.last = child.fail if child.fail.c_end else child.fail.last",
      "                            break",
      "                        p = p.fail",
      "                    if not p:",
      "                        child.fail = root",
      "                        child.last = root",
      "                queue.append(child)",
      "",
      "    def match(self, text):",
      "        root, p = self, self",
      "        ret, unique = [], set()",
      "        for i, c in enumerate(text):",
      "            while p != root and c not in p.children:  # type: ignore",
      "                p = p.fail  #  失配指针发挥作用 # type: ignore",
      "            # 如果没有匹配的，从 root 开始重新匹配",
      "            p = p.children[c] if c in p.children else root  # type: ignore",
      "            node: Trie = p",
      "            while node != root:",
      "                #  收集出可以匹配的模式串",
      "                if node.c_end:",
      "                    pos = i - len(node.string) + 1",
      "                    # console.log(`匹配模式串 ${node.pattern}其起始位置在${pos}`)",
      "                    if not node.string in unique:",
      "                        unique.add(node.string)",
      "                        ret.append(node.string)",
      "                node = node.fail  # type: ignore",
      "        return ret"
    ],
    "prefix": "trie_ac"
  }
}
